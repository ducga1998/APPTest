'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var createReactContext = _interopDefault(require('create-react-context'));
var React = _interopDefault(require('react'));

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var StateContext = createReactContext(null);

var Container = function () {
  function Container(state) {
    _classCallCheck(this, Container);

    this._listeners = [];

    // eslint-disable-next-line no-unused-expressions
    state && (this.state = state);
  }

  Container.prototype.setStateSync = function setStateSync(state) {
    this.state = Object.assign({}, this.state, state);
    this._listeners.forEach(function (fn) {
      return fn(state);
    });
  };

  Container.prototype.setState = function setState(updater, callback) {
    var _this = this;

    return Promise.resolve().then(function () {
      var nextState = void 0;

      if (typeof updater === 'function') {
        nextState = updater(_this.state);
      } else {
        nextState = updater;
      }

      if (nextState == null) {
        if (callback) callback();
        return;
      }

      _this.state = Object.assign({}, _this.state, nextState);

      var promises = _this._listeners.map(function (listener) {
        return listener(nextState);
      });

      return Promise.all(promises).then(function () {
        if (callback) {
          return callback();
        }
      });
    });
  };

  Container.prototype.subscribe = function subscribe(fn) {
    this._listeners.push(fn);
  };

  Container.prototype.unsubscribe = function unsubscribe(fn) {
    this._listeners = this._listeners.filter(function (f) {
      return f !== fn;
    });
  };

  return Container;
}();

var DUMMY_STATE = {};

var Subscribe = function (_React$Component) {
  _inherits(Subscribe, _React$Component);

  function Subscribe() {
    var _temp, _this2, _ret;

    _classCallCheck(this, Subscribe);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this2 = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this2), _this2.state = {}, _this2.instances = [], _this2.unmounted = false, _this2.onUpdate = function () {
      return new Promise(function (resolve) {
        if (!_this2.unmounted) {
          _this2.setState(DUMMY_STATE, resolve);
        } else {
          resolve();
        }
      });
    }, _temp), _possibleConstructorReturn(_this2, _ret);
  }

  Subscribe.prototype.componentWillUnmount = function componentWillUnmount() {
    this.unmounted = true;
    this._unsubscribe();
  };

  Subscribe.prototype._unsubscribe = function _unsubscribe() {
    var _this3 = this;

    this.instances.forEach(function (container) {
      container.unsubscribe(_this3.onUpdate);
    });
  };

  Subscribe.prototype._createInstances = function _createInstances(map, containers) {
    var _this4 = this;

    this._unsubscribe();

    if (map === null) {
      throw new Error('You must wrap your <Subscribe> components with a <Provider>');
    }

    var safeMap = map;
    var instances = containers.map(function (ContainerItem) {
      var instance = void 0;

      if ((typeof ContainerItem === 'undefined' ? 'undefined' : _typeof(ContainerItem)) === 'object' && ContainerItem instanceof Container) {
        instance = ContainerItem;
      } else {
        instance = safeMap.get(ContainerItem);

        if (!instance) {
          instance = new ContainerItem();
          safeMap.set(ContainerItem, instance);
        }
      }

      instance.unsubscribe(_this4.onUpdate);
      instance.subscribe(_this4.onUpdate);

      return instance;
    });

    this.instances = instances;
    return instances;
  };

  Subscribe.prototype.render = function render() {
    var _this5 = this;

    return React.createElement(
      StateContext.Consumer,
      null,
      function (map) {
        return Reflect.apply(_this5.props.children, null, _this5._createInstances(map, _this5.props.to));
      }
    );
  };

  return Subscribe;
}(React.Component);

var SubscribeOne = function (_React$Component2) {
  _inherits(SubscribeOne, _React$Component2);

  function SubscribeOne() {
    var _temp2, _this6, _ret2;

    _classCallCheck(this, SubscribeOne);

    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    return _ret2 = (_temp2 = (_this6 = _possibleConstructorReturn(this, _React$Component2.call.apply(_React$Component2, [this].concat(args))), _this6), _this6.state = {}, _this6.instance = null, _this6.unmounted = false, _this6.onUpdate = function (changedState) {
      return new Promise(function (resolve) {
        if (!_this6.unmounted && Array.isArray(_this6.props.bind) && Object.keys(changedState).filter(function (key) {
          return _this6.props.bind.includes(key);
        }).length > 0) {
          _this6.setState(DUMMY_STATE, resolve);
        } else {
          resolve();
        }
      });
    }, _temp2), _possibleConstructorReturn(_this6, _ret2);
  }

  SubscribeOne.prototype.componentWillUnmount = function componentWillUnmount() {
    this.unmounted = true;
    this._unsubscribe();
  };

  SubscribeOne.prototype._unsubscribe = function _unsubscribe() {
    this.instance && this.instance.unsubscribe(this.onUpdate);
  };

  SubscribeOne.prototype._createInstance = function _createInstance(map, container) {
    this._unsubscribe();
    if (map === null) {
      throw new Error('You must wrap your <Subscribe> components with a <Provider>');
    }
    var safeMap = map;
    if ((typeof container === 'undefined' ? 'undefined' : _typeof(container)) === 'object' && container instanceof Container) {
      this.instance = container;
    } else {
      this.instance = safeMap.get(container);

      if (!this.instance) {
        this.instance = new container();
        safeMap.set(container, this.instance);
      }
    }

    this.instance.unsubscribe(this.onUpdate);
    this.instance.subscribe(this.onUpdate);

    return this.instance;
  };

  SubscribeOne.prototype.render = function render() {
    var _this7 = this;

    return React.createElement(
      StateContext.Consumer,
      null,
      function (map) {
        return _this7.props.children(_this7._createInstance(map, _this7.props.to));
      }
    );
  };

  return SubscribeOne;
}(React.Component);

function Provider(props) {
  var childMap = new Map();
  if (props.inject) {
    props.inject.forEach(function (instance) {
      childMap.set(instance.constructor, instance);
    });
  }
  return React.createElement(
    StateContext.Provider,
    { value: childMap },
    props.children
  );
}

exports.StateContext = StateContext;
exports.Container = Container;
exports.Subscribe = Subscribe;
exports.SubscribeOne = SubscribeOne;
exports.Provider = Provider;
